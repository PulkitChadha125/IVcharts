def calculate_iv(df, window=20, timeframe='1D', symbol=None, risk_free_rate=0.06, 
                manual_strike=None, manual_expiry=None, manual_option_type=None, manual_future_symbol=None):
    """
    Calculate Implied Volatility using py_vollib Black model (for options) or Historical Volatility (for underlying)
    
    For Options:
    - Uses py_vollib Black model with option prices (appropriate for options on futures)
    - Requires: option_price, futures_price, strike, time_to_expiry
    
    Parameters:
    - manual_strike: Optional manual strike price (overrides parsed value)
    - manual_expiry: Optional manual expiry datetime string (overrides parsed value) - used for option symbol and time_to_expiry calculation
    - manual_option_type: Optional manual option type 'c' or 'p' (overrides parsed value)
    - manual_future_symbol: Optional future symbol (from SymbolSetting.csv). If provided, uses this instead of reconstructing from option expiry
    
    For Underlying Assets (fallback):
    - Uses rolling standard deviation of log returns (Historical Volatility)
    - Formula: IV = std(ln(P_t/P_{t-1})) × √(periods_per_year) × 100
    
    Returns annualized volatility as percentage (%)
    """
    if df is None or len(df) < 2:
        return None
    
    # Check if symbol is an option or if manual option parameters are provided
    option_info = None
    
    # If manual parameters provided, create option_info dict
    if manual_strike is not None or manual_expiry is not None or manual_option_type:
        # Try to parse symbol first, then override with manual values
        parsed_info = parse_option_symbol(symbol) if symbol else None
        
        # Parse expiry datetime if provided
        expiry_date = None
        if manual_expiry:
            try:
                # datetime-local format: "YYYY-MM-DDTHH:mm"
                expiry_date = datetime.strptime(manual_expiry, '%Y-%m-%dT%H:%M')
            except ValueError:
                try:
                    # Try ISO format
                    expiry_date = datetime.fromisoformat(manual_expiry.replace('Z', '+00:00'))
                except:
                    try:
                        # Try date-only format: "YYYY-MM-DD"
                        expiry_date = datetime.strptime(manual_expiry, '%Y-%m-%d')
                    except:
                        print(f"Could not parse expiry date: {manual_expiry}")
        
        # Extract underlying symbol and determine exchange
        underlying = None
        is_mcx_underlying = False
        if parsed_info:
            underlying = parsed_info['underlying']
            is_mcx_underlying = parsed_info.get('is_mcx', False)
        elif ':' in symbol:
            # Extract from format like "NSE:RELIANCE-EQ" or "MCX:CRUDEOILM..."
            exchange_part = symbol.split(':')[0]
            is_mcx_underlying = (exchange_part.upper() == 'MCX')
            underlying = symbol.split(':')[-1].split('-')[0]
        else:
            # Use symbol as-is, but try to remove option suffixes
            underlying = symbol.replace('CE', '').replace('PE', '').rstrip('0123456789')
        
        # If expiry_date was parsed but doesn't have correct time (midnight or not set), adjust it
        if expiry_date and (expiry_date.hour == 0 and expiry_date.minute == 0):
            # Time was not specified, set based on exchange
            if is_mcx_underlying:
                expiry_date = expiry_date.replace(hour=23, minute=20, second=0)  # 11:20 PM IST for MCX
            else:
                expiry_date = expiry_date.replace(hour=15, minute=15, second=0)  # 3:15 PM IST for NSE
        
        option_info = {
            'underlying': underlying if underlying else symbol,
            'strike': manual_strike if manual_strike is not None else (parsed_info['strike'] if parsed_info else None),
            'expiry_date': expiry_date if expiry_date else (parsed_info['expiry_date'] if parsed_info else None),
            'option_type': manual_option_type if manual_option_type else (parsed_info['option_type'] if parsed_info else 'c'),
            'is_option': True
        }
        
        # Validate required fields
        if option_info['strike'] is None or option_info['expiry_date'] is None:
            print("Manual option parameters incomplete, trying to parse symbol...")
            option_info = parse_option_symbol(symbol) if symbol else None
    else:
        # Auto-detect from symbol
        option_info = parse_option_symbol(symbol) if symbol else None
    
    if option_info and PY_VOLLIB_AVAILABLE and option_info.get('strike') and option_info.get('expiry_date'):
        # Calculate IV using py_vollib Black model for options (options on futures)
        print(f"Calculating IV for {symbol}...")
        
        underlying_symbol = option_info['underlying']
        expiry_date = option_info['expiry_date']  # Option expiry (used for option symbol and time_to_expiry calculation)
        
        # Normalize expiry_date to timezone-naive to avoid timezone mismatch errors
        if expiry_date.tzinfo is not None:
            expiry_date = expiry_date.replace(tzinfo=None)
        
        # Get future symbol - use manual_future_symbol if provided (from SymbolSetting.csv)
        # Otherwise, reconstruct from underlying and option expiry (may be wrong if option expiry != future expiry)
        if manual_future_symbol:
            future_symbol = manual_future_symbol
        else:
            # Fallback: reconstruct future symbol from underlying and option expiry
            # NOTE: This may be incorrect if option expiry != future expiry
            future_symbol = get_future_symbol(underlying_symbol, expiry_date)
        
        if future_symbol:
            # Fetch historical data for future symbol
            print(f"  Fetching future data for: {future_symbol}")
            df_future = safe_fetch_ohlc(future_symbol, timeframe)
            
            if df_future is None or len(df_future) == 0:
                error_msg = f"Could not fetch historical data for future symbol {future_symbol}"
                print(f"  ❌ {error_msg}")
                add_log('ERROR', error_msg, {
                    'future_symbol': future_symbol,
                    'timeframe': timeframe,
                    'underlying_symbol': underlying_symbol
                })
                print(f"  Falling back to historical volatility")
            else:
                print(f"  ✓ Fetched {len(df_future)} candles for {future_symbol}")
                
                # Prepare option dataframe - keep only date and close
                df_option = df[['date', 'close']].copy()
                df_option['date'] = pd.to_datetime(df_option['date'])
                # Remove timezone info for consistent merging (keep exact timestamp)
                if df_option['date'].dt.tz is not None:
                    df_option['date'] = df_option['date'].dt.tz_localize(None)
                
                # Prepare future dataframe - keep only date and close, rename close to fclose
                df_future_prep = df_future[['date', 'close']].copy()
                df_future_prep.rename(columns={'close': 'fclose'}, inplace=True)
                df_future_prep['date'] = pd.to_datetime(df_future_prep['date'])
                # Remove timezone info for consistent merging (keep exact timestamp)
                if df_future_prep['date'].dt.tz is not None:
                    df_future_prep['date'] = df_future_prep['date'].dt.tz_localize(None)
                
                # Round timestamps to nearest minute to handle slight time differences
                # This ensures proper matching for minute-level data
                df_option['date_rounded'] = df_option['date'].dt.round('1min')
                df_future_prep['date_rounded'] = df_future_prep['date'].dt.round('1min')
                
                # Debug: Print date ranges
                if len(df_option) > 0 and len(df_future_prep) > 0:
                    print(f"  Option date range: {df_option['date'].min()} to {df_option['date'].max()}")
                    print(f"  Future date range: {df_future_prep['date'].min()} to {df_future_prep['date'].max()}")
                
                # Merge option and future data by rounded timestamp (exact minute match)
                # This prevents cartesian products while ensuring proper matching
                print(f"  Merging option data ({len(df_option)} rows) with future data ({len(df_future_prep)} rows)...")
                df_merged = pd.merge(df_option[['date', 'close', 'date_rounded']], 
                                    df_future_prep[['fclose', 'date_rounded']], 
                                    on='date_rounded', 
                                    how='inner')
                
                # Drop the rounded date column and keep original date from option
                df_merged = df_merged.drop(columns=['date_rounded'])
                
                if len(df_merged) == 0:
                    error_msg = f"No matching dates between option and future data. Option dates: {len(df_option)}, Future dates: {len(df_future_prep)}"
                    print(f"  ❌ {error_msg}")
                    add_log('WARNING', error_msg, {
                        'option_symbol': symbol,
                        'future_symbol': future_symbol,
                        'option_rows': len(df_option),
                        'future_rows': len(df_future_prep)
                    })
                    print(f"  Falling back to historical volatility")
                else:
                    print(f"  ✓ Merged data: {len(df_merged)} matching rows")
                    # Check for duplicate dates (shouldn't happen with proper merge)
                    if len(df_merged) != len(df_merged['date'].unique()):
                        print(f"  ⚠ Warning: Found duplicate dates in merged data. Deduplicating...")
                        df_merged = df_merged.drop_duplicates(subset=['date'], keep='first')
                        print(f"  ✓ After deduplication: {len(df_merged)} rows")
                    
                    # Safety check: if merged data is too large, something went wrong
                    if len(df_merged) > len(df_option) * 2:
                        error_msg = f"Merged data has {len(df_merged)} rows, which is suspiciously large (option had {len(df_option)} rows). This suggests a merge issue."
                        print(f"  ❌ {error_msg}")
                        add_log('ERROR', error_msg, {
                            'symbol': symbol,
                            'future_symbol': future_symbol,
                            'option_rows': len(df_option),
                            'future_rows': len(df_future_prep),
                            'merged_rows': len(df_merged)
                        })
                        print(f"  Falling back to historical volatility")
                    else:
                        # Calculate IV for each row using historical future prices
                        print(f"  Starting IV calculation loop for {len(df_merged)} rows...")
                        iv_values = []
                        rows_processed = 0
                        
                        for idx, row in df_merged.iterrows():
                            rows_processed += 1
                            if rows_processed % 1000 == 0:
                                print(f"  Processing IV calculation: {rows_processed}/{len(df_merged)} rows...")
                            
                            option_price = row['close']
                            future_price = row['fclose']
                            
                            # Validate prices are reasonable
                            if pd.isna(option_price) or pd.isna(future_price):
                                iv_values.append(np.nan)
                                continue
                            
                            if option_price <= 0 or future_price <= 0:
                                iv_values.append(np.nan)
                                continue
                            
                            # Additional validation: check if prices are reasonable
                            # Option price should not be more than 50% of strike (for calls) or underlying (for puts)
                            # This filters out obvious data errors
                            strike_price = option_info['strike']
                            if option_info['option_type'] == 'c':
                                if option_price > strike_price * 0.5 or option_price > future_price * 0.5:
                                    iv_values.append(np.nan)
                                    continue
                            else:  # put
                                if option_price > strike_price * 0.5:
                                    iv_values.append(np.nan)
                                    continue
                            
                            # Future price should be reasonable relative to strike (within 50% to 200%)
                            if future_price < strike_price * 0.5 or future_price > strike_price * 2.0:
                                iv_values.append(np.nan)
                                continue
                            
                            if option_price > 0 and future_price > 0:
                                # Calculate time to expiry for this timestamp
                                row_date = row['date'] if isinstance(row['date'], datetime) else pd.to_datetime(row['date'])
                                
                                # Fix timezone mismatch: make row_date timezone-naive if needed
                                if row_date.tzinfo is not None:
                                    # If row_date is timezone-aware, convert to naive
                                    row_date = row_date.replace(tzinfo=None)
                                
                                # expiry_date is already normalized to naive above, so we can use it directly
                                # Calculate time to expiry in years using option expiry
                                # Indian brokers typically use calendar days (365) for time to expiry calculation
                                # However, some use trading days (252). We'll use calendar days as it's more standard.
                                time_diff = expiry_date - row_date
                                total_seconds = time_diff.total_seconds()
                                
                                # Convert to years using calendar days (365 days per year)
                                # This is the standard approach used by most Indian brokers
                                # Note: Using 365.25 accounts for leap years, but 365 is more common in options pricing
                                time_to_expiry = total_seconds / (365.0 * 24 * 3600)
                                
                                # Ensure time to expiry is reasonable (not negative, not too large)
                                if time_to_expiry <= 0:
                                    iv_values.append(np.nan)
                                    continue
                                if time_to_expiry > 2.0:  # More than 2 years seems wrong
                                    print(f"  Warning: Time to expiry seems too large: {time_to_expiry:.4f} years")
                                    iv_values.append(np.nan)
                                    continue
                                
                                # Alternative: Use trading days (more accurate for options)
                                # trading_days_per_year = 252
                                # calendar_days = time_diff.days
                                # trading_days = calendar_days * (trading_days_per_year / 365.25)
                                # time_to_expiry = trading_days / trading_days_per_year
                                
                                if time_to_expiry > 0:
                                    # Calculate IV using py_vollib Black model with historical future price
                                    iv_decimal = calculate_iv_pyvollib(
                                        option_price=option_price,
                                        underlying_price=future_price,
                                        strike=option_info['strike'],
                                        time_to_expiry=time_to_expiry,
                                        risk_free_rate=risk_free_rate,
                                        option_type=option_info['option_type']
                                    )
                                    
                                    if iv_decimal is not None:
                                        iv_values.append(iv_decimal * 100)  # Convert to percentage
                                    else:
                                        iv_values.append(np.nan)
                                else:
                                    iv_values.append(np.nan)  # Option expired
                            else:
                                iv_values.append(np.nan)
                        
                        print(f"  ✓ Completed IV calculation loop. Processed {rows_processed} rows.")
                        
                        # Add IV column
                        df_merged['iv'] = iv_values
                    
                    # Filter out outliers (IV values that are too different from neighbors)
                    # This prevents glitches from bad data
                    iv_series = pd.Series(iv_values)
                    
                    # Calculate rolling median to detect outliers
                    window_size = min(5, max(3, len(iv_series) // 10 + 1))  # Use 5 or 10% of data, whichever is smaller, but at least 3
                    if window_size >= 3 and len(iv_series) > window_size:
                        rolling_median = iv_series.rolling(window=window_size, center=True, min_periods=1).median()
                        rolling_std = iv_series.rolling(window=window_size, center=True, min_periods=1).std()
                        
                        # Replace outliers (values more than 3 standard deviations from rolling median)
                        # Only if the value is significantly different (more than 20% difference)
                        for i in range(len(iv_series)):
                            if pd.notna(iv_series.iloc[i]) and pd.notna(rolling_median.iloc[i]):
                                median_val = rolling_median.iloc[i]
                                std_val = rolling_std.iloc[i] if pd.notna(rolling_std.iloc[i]) else median_val * 0.1
                                
                                # Check if value is an outlier (more than 3 std devs OR more than 20% different)
                                if abs(iv_series.iloc[i] - median_val) > max(3 * std_val, median_val * 0.2):
                                    # Replace with median of neighbors
                                    neighbor_indices = [j for j in range(max(0, i-2), min(len(iv_series), i+3)) if j != i and pd.notna(iv_series.iloc[j])]
                                    if neighbor_indices:
                                        neighbor_median = iv_series.iloc[neighbor_indices].median()
                                        iv_series.iloc[i] = neighbor_median
                    
                    df_merged['iv'] = iv_series.values
                    
                    # Fill NaN values with forward fill, then backward fill
                    df_merged['iv'] = df_merged['iv'].ffill().bfill().fillna(0)
                    
                    # Add required columns for CSV export
                    df_merged['option_name'] = symbol  # Option symbol name
                    df_merged['underlying_name'] = future_symbol  # Underlying future name
                    
                    # Add metadata columns
                    if option_info.get('strike'):
                        df_merged['strike'] = option_info['strike']
                    if option_info.get('expiry_date'):
                        df_merged['expiry'] = option_info['expiry_date'].strftime('%Y-%m-%d %H:%M:%S')
                    if option_info.get('option_type'):
                        df_merged['option_type'] = option_info['option_type']
                    df_merged['timeframe'] = timeframe
                    
                    # Ensure date is in the right format
                    df_merged['date'] = pd.to_datetime(df_merged['date'])
                    
                    # Get valid IVs for logging
                    valid_ivs = [iv for iv in iv_values if iv is not None and not (isinstance(iv, float) and (np.isnan(iv) or np.isinf(iv)))]
                    if len(valid_ivs) > 0:
                        print(f"  ✓ Calculated IV: {len(valid_ivs)} values (range: {min(valid_ivs):.2f}% - {max(valid_ivs):.2f}%)")
                    else:
                        print(f"  ⚠ Warning: No valid IV values calculated. All {len(iv_values)} values are NaN or invalid.")
                        add_log('WARNING', f'No valid IV values calculated for {symbol}', {
                            'symbol': symbol,
                            'future_symbol': future_symbol,
                            'total_rows': len(iv_values),
                            'valid_ivs': 0
                        })
                    
                    # Even if all IVs are NaN, return the dataframe so we can still display the data
                    # The frontend can handle NaN/zero values
                    return df_merged
        else:
            error_msg = f"Could not construct future symbol for underlying {underlying_symbol}"
            print(f"  ❌ {error_msg}")
            add_log('ERROR', error_msg, {
                'underlying_symbol': underlying_symbol,
                'expiry_date': str(expiry_date),
                'symbol': symbol
            })
            print(f"  Falling back to historical volatility")
        
        print(f"  Failed to calculate IV with py_vollib Black model, falling back to historical volatility")
    
    # Fallback to Historical Volatility calculation
    print(f"  Using Historical Volatility calculation (fallback)")
    
    # Calculate log returns
    df['returns'] = np.log(df['close'] / df['close'].shift(1))
    
    # Determine annualization factor based on timeframe
    timeframe_factors = {
        '1s': 252 * 375 * 60,  # 1 second: 22500 seconds per day * 252 days
        '1': 252 * 375,  # 1 minute: 375 minutes per day * 252 days
        '5': 252 * 75,   # 5 minutes: 75 periods per day
        '15': 252 * 25,  # 15 minutes: 25 periods per day
        '30': 252 * 12,  # 30 minutes: 12 periods per day
        '60': 252 * 6,   # 1 hour: 6 periods per day
        '120': 252 * 3,  # 2 hours: 3 periods per day
        '1D': 252,       # Daily: 252 trading days
    }
    
    # Get the appropriate factor, default to daily if not found
    periods_per_year = timeframe_factors.get(str(timeframe), 252)
    
    # Calculate rolling volatility (annualized)
    if len(df) > window:
        df['iv'] = df['returns'].rolling(window=min(window, len(df))).std() * np.sqrt(periods_per_year) * 100
    else:
        # If not enough data, use all available data
        df['iv'] = df['returns'].std() * np.sqrt(periods_per_year) * 100
    
    # Fill NaN values with forward fill
    df['iv'] = df['iv'].ffill()
    
    # Fill any remaining NaN with 0
    df['iv'] = df['iv'].fillna(0)
    
    # Add timeframe metadata for CSV export
    df['timeframe'] = timeframe
    
    # For historical volatility fallback, still try to add option metadata if it's an option symbol
    # This ensures CSV always has the required columns
    if symbol:
        # Try to parse option symbol and get underlying price
        option_info = parse_option_symbol(symbol)
        if option_info and option_info.get('underlying'):
            underlying_symbol = option_info['underlying']
            expiry_date = option_info.get('expiry_date')
            if expiry_date:
                future_symbol = get_future_symbol(underlying_symbol, expiry_date)
                if future_symbol:
                    # Try to fetch historical future data for fclose column
                    print(f"  Attempting to fetch future data for fallback: {future_symbol}")
                    df_future = safe_fetch_ohlc(future_symbol, timeframe)
                    
                    if df_future is not None and len(df_future) > 0:
                        # Merge with future data to get fclose
                        df_future_prep = df_future[['date', 'close']].copy()
                        df_future_prep.rename(columns={'close': 'fclose'}, inplace=True)
                        df_future_prep['date'] = pd.to_datetime(df_future_prep['date'])
                        df['date'] = pd.to_datetime(df['date'])
                        
                        df = pd.merge(df, df_future_prep, on='date', how='left')
                        print(f"  Merged future data: {df['fclose'].notna().sum()} rows have fclose values")
                    else:
                        # If can't fetch future data, use current LTP for all rows
                        underlying_price = get_future_ltp(future_symbol)
                        if underlying_price:
                            df['fclose'] = underlying_price
                            print(f"  Using current LTP for fclose: {underlying_price}")
                    
                    # Always add required columns
                    df['option_name'] = symbol
                    df['underlying_name'] = future_symbol
                    if option_info.get('strike'):
                        df['strike'] = option_info['strike']
                    if expiry_date:
                        df['expiry'] = expiry_date.strftime('%Y-%m-%d %H:%M:%S')
                    if option_info.get('option_type'):
                        df['option_type'] = option_info['option_type']
        else:
            # Not an option, just add symbol name
            df['symbol_name'] = symbol
    
    return df
